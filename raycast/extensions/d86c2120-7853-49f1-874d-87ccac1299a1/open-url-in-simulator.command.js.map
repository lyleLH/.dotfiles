{
  "version": 3,
  "sources": ["../src/open-url-in-simulator.command.tsx", "../src/shared/exec-async.ts", "../src/shared/group-by.ts", "../src/services/xcode.service.ts", "../src/models/xcode-simulator/xcode-simulator-open-url-error.model.ts", "../src/services/xcode-simulator.service.ts"],
  "sourcesContent": ["import { XcodeSimulatorService } from \"./services/xcode-simulator.service\";\nimport { closeMainWindow, launchCommand, LaunchProps, LaunchType, showToast, Toast } from \"@raycast/api\";\nimport {\n  XcodeSimulatorOpenUrlError,\n  XcodeSimulatorOpenUrlErrorReason,\n} from \"./models/xcode-simulator/xcode-simulator-open-url-error.model\";\n\nexport default async (props: LaunchProps<{ arguments: { url: string } }>) => {\n  // Show loading toast\n  const toast = await showToast({\n    style: Toast.Style.Animated,\n    title: \"Opening URL in Simulator\",\n  });\n  try {\n    // Try to open url\n    await XcodeSimulatorService.openUrl(props.arguments.url);\n    // Close main window\n    await closeMainWindow();\n  } catch (error) {\n    // Check if error is an instance of XcodeSimulatorOpenUrlError\n    if (error instanceof XcodeSimulatorOpenUrlError) {\n      // Switch on reason\n      switch (error.reason) {\n        case XcodeSimulatorOpenUrlErrorReason.badUrl:\n          // Show failure toast\n          toast.style = Toast.Style.Failure;\n          toast.title = \"Please enter a valid url\";\n          break;\n        case XcodeSimulatorOpenUrlErrorReason.bootedSimulatorMissing:\n          toast.style = Toast.Style.Failure;\n          toast.title = \"No simulator is booted, please boot a simulator to open a url.\";\n          toast.primaryAction = {\n            title: \"Manage Simulators\",\n            onAction: async (toast) => {\n              await launchCommand({ name: \"manage-simulators.command\", type: LaunchType.UserInitiated });\n              await toast.hide();\n            },\n          };\n          break;\n        case XcodeSimulatorOpenUrlErrorReason.xcodeInstallationMissing:\n          // Hide toast\n          await toast.hide();\n          // Launch manage simulators command.\n          // As the command is wrapped inside a `XcodeInstallationVerifier` component\n          // the user will be informed that an installation of Xcode is required\n          await launchCommand({ name: \"manage-simulators.command\", type: LaunchType.UserInitiated });\n          break;\n      }\n    } else {\n      // Show failure toast\n      toast.style = Toast.Style.Failure;\n      toast.title = \"An error occurred while trying to open the url\";\n      toast.message = `${error}`;\n    }\n  }\n};\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n", "/**\n * Group a given array by a given key into a Map\n * Source: https://stackoverflow.com/a/38327540\n * @param list The list\n * @param keyProvider The key provider that is used for grouping\n */\nexport function groupBy<Key, Value>(\n  list: Value[],\n  keyProvider: (input: Value) => Key\n): { key: Key; values: Value[] }[] {\n  // Initialize the grouping Map\n  const map = new Map<Key, Value[]>();\n  // For each value in the list\n  for (const value of list) {\n    // Retrieve the key from the key provider\n    const key = keyProvider(value);\n    // Retrieve the current values from the grouping Map\n    const values = map.get(key);\n    // Check if values is falsy\n    if (!values) {\n      // Set value as array to grouping Map\n      map.set(key, [value]);\n    } else {\n      // Push value to collection\n      values.push(value);\n    }\n  }\n  // Return groups\n  return Array.from(map.keys()).map((key) => {\n    return { key: key, values: map.get(key) ?? [] };\n  });\n}\n", "import { execAsync } from \"../shared/exec-async\";\nimport { getApplications } from \"@raycast/api\";\n\n/**\n * XcodeService\n */\nexport class XcodeService {\n  /**\n   * Xcode application bundle identifier\n   */\n  static get bundleIdentifier(): string {\n    return \"com.apple.dt.Xcode\";\n  }\n\n  /**\n   * Xcode download url (Mac App Store)\n   */\n  static get downloadUrl(): string {\n    return \"https://apps.apple.com/app/id497799835\";\n  }\n\n  /**\n   * Xcode Developer Documentation URL Scheme\n   */\n  static get developerDocumentationURLScheme(): string {\n    return \"x-xcode-documentation://\";\n  }\n\n  /**\n   * Retrieve boolean if Xcode is installed\n   */\n  static async isXcodeInstalled(): Promise<boolean> {\n    const applications = await getApplications();\n    return !!applications.find((application) => application.bundleId === XcodeService.bundleIdentifier);\n  }\n\n  /**\n   * Retrieve boolean if Xcode is currently running\n   */\n  static async isXcodeRunning(): Promise<boolean> {\n    try {\n      // prep Xcode process status\n      const output = await execAsync(\"pgrep Xcode\");\n      // Xcode is running if standard output is not empty\n      return output.stdout.trim().length !== 0;\n    } catch {\n      // On error Xcode is not running\n      return false;\n    }\n  }\n\n  /**\n   * Launch Xcode\n   */\n  static launchXcode(): Promise<void> {\n    return execAsync(\n      [\n        // Open Xcode in background (-j)\n        // via bundle identifier (-b)\n        `open -j -b ${XcodeService.bundleIdentifier}`,\n        // Sleep for two seconds to ensure\n        // the process is truly running\n        \"sleep 2\",\n      ].join(\" && \")\n    ).then();\n  }\n}\n", "/**\n * A Xcode Simulator Open Url Error\n */\nexport class XcodeSimulatorOpenUrlError extends Error {\n  /**\n   * Creates a new instance of `XcodeSimulatorOpenUrlError`\n   * @param reason The reason why the url could not be opened\n   */\n  constructor(public reason: XcodeSimulatorOpenUrlErrorReason) {\n    super(reason);\n  }\n}\n\n/**\n * A Xcode Simulator Open Url Error Reason\n */\nexport enum XcodeSimulatorOpenUrlErrorReason {\n  badUrl = \"Bad Url\",\n  xcodeInstallationMissing = \"Xcode is not installed\",\n  bootedSimulatorMissing = \"No simulator booted\",\n}\n", "import { XcodeSimulator } from \"../models/xcode-simulator/xcode-simulator.model\";\nimport { execAsync } from \"../shared/exec-async\";\nimport { XcodeSimulatorGroup } from \"../models/xcode-simulator/xcode-simulator-group.model\";\nimport { XcodeSimulatorState } from \"../models/xcode-simulator/xcode-simulator-state.model\";\nimport { XcodeSimulatorAppAction } from \"../models/xcode-simulator/xcode-simulator-app-action.model\";\nimport { XcodeSimulatorAppPrivacyAction } from \"../models/xcode-simulator/xcode-simulator-app-privacy-action.model\";\nimport { XcodeSimulatorAppPrivacyServiceType } from \"../models/xcode-simulator/xcode-simulator-app-privacy-service-type.model\";\nimport { groupBy } from \"../shared/group-by\";\nimport { XcodeService } from \"./xcode.service\";\nimport {\n  XcodeSimulatorOpenUrlError,\n  XcodeSimulatorOpenUrlErrorReason,\n} from \"../models/xcode-simulator/xcode-simulator-open-url-error.model\";\n\n/**\n * XcodeSimulatorService\n */\nexport class XcodeSimulatorService {\n  /**\n   * Launches simulator application\n   */\n  static launchSimulatorApplication(): Promise<void> {\n    return execAsync(`open -b \"com.apple.iphonesimulator\"`).then();\n  }\n\n  /**\n   * Retrieve all XcodeSimulatorGroups\n   */\n  static async xcodeSimulatorGroups(): Promise<XcodeSimulatorGroup[]> {\n    const simulators = await XcodeSimulatorService.xcodeSimulators();\n    return groupBy(simulators, (simulator) => simulator.runtime)\n      .map((group) => {\n        return { runtime: group.key, simulators: group.values };\n      })\n      .sort((lhs, rhs) => lhs.runtime.localeCompare(rhs.runtime));\n  }\n\n  /**\n   * Retrieve all installed XcodeSimulators\n   */\n  static async xcodeSimulators(): Promise<XcodeSimulator[]> {\n    // Execute command\n    const output = await execAsync(\"xcrun simctl list -j -v devices\");\n    // Parse stdout as JSON\n    const devicesResponseJSON = JSON.parse(output.stdout);\n    // Check if JSON or devices within the JSON are not available\n    if (!devicesResponseJSON || !devicesResponseJSON.devices) {\n      // Return empty simulators array\n      throw [];\n    }\n    // Initialize XcodeSimulators\n    const simulators: XcodeSimulator[] = [];\n    // For each DeviceGroup\n    for (const deviceGroup in devicesResponseJSON.devices) {\n      // Initialize runtime components from DeviceGroup\n      const runtimeComponents = deviceGroup.substring(deviceGroup.lastIndexOf(\".\") + 1).split(\"-\");\n      // Initialize runtime string\n      const runtime = [runtimeComponents.shift(), runtimeComponents.join(\".\")].join(\" \");\n      // Push Simulators in DeviceGroup\n      simulators.push(\n        ...devicesResponseJSON.devices[deviceGroup].map((simulator: XcodeSimulator) => {\n          simulator.runtime = runtime;\n          return simulator;\n        })\n      );\n    }\n    // Return XcodeSimulators\n    return simulators;\n  }\n\n  /**\n   * Boot XcodeSimulator\n   * @param xcodeSimulator The XcodeSimulator to boot\n   */\n  static boot(xcodeSimulator: XcodeSimulator): Promise<void> {\n    return execAsync(`xcrun simctl boot ${xcodeSimulator.udid}`).then(() => {\n      // Silently launch Simulator application\n      XcodeSimulatorService.launchSimulatorApplication();\n    });\n  }\n\n  /**\n   * Shutdown XcodeSimulator\n   * @param xcodeSimulator The XcodeSimulator to shutdown\n   */\n  static shutdown(xcodeSimulator: XcodeSimulator): Promise<void> {\n    // Shutdown Simulator\n    return execAsync(`xcrun simctl shutdown ${xcodeSimulator.udid}`).then();\n  }\n\n  /**\n   * Toggle XcodeSimulator\n   */\n  static toggle(xcodeSimulator: XcodeSimulator): Promise<void> {\n    switch (xcodeSimulator.state) {\n      case XcodeSimulatorState.booted:\n        return XcodeSimulatorService.shutdown(xcodeSimulator);\n      case XcodeSimulatorState.shuttingDown:\n        return Promise.resolve();\n      case XcodeSimulatorState.shutdown:\n        return XcodeSimulatorService.boot(xcodeSimulator);\n    }\n  }\n\n  /**\n   * Perform a XcodeSimulator AppAction\n   * @param action The XcodeSimulatorAppAction\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async app(\n    action: XcodeSimulatorAppAction,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    // Launch application by bundle identifier\n    return execAsync([\"xcrun\", \"simctl\", action, xcodeSimulator.udid, bundleIdentifier].join(\" \")).then();\n  }\n\n  /**\n   * Perform a XcodeSimulator AppPrivacyAction for a given AppPrivacyServiceType\n   * @param action The XcodeSimulatorAppPrivacyAction\n   * @param serviceType The XcodeSimulatorAppPrivacyServiceType\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async appPrivacy(\n    action: XcodeSimulatorAppPrivacyAction,\n    serviceType: XcodeSimulatorAppPrivacyServiceType,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    return execAsync(\n      [\"xcrun\", \"simctl\", \"privacy\", xcodeSimulator.udid, action, serviceType, bundleIdentifier].join(\" \")\n    ).then();\n  }\n\n  /**\n   * Bool value if a given url is valid to be opened in a simulator\n   * @param url The url to validate.\n   */\n  static isValidUrl(url: string): boolean {\n    return /\\w+:\\/\\/+/.test(url);\n  }\n\n  /**\n   * Opens a URL in a Simulator\n   * @param url The url which should be opened\n   * @param simulator The optional Simulator where the url should be opened.\n   */\n  static async openUrl(url: string, simulator?: XcodeSimulator) {\n    // Trim url\n    const trimmedUrl = url.trim();\n    // Check if the url has a valid scheme e.g. (maps://, https://raycast.com)\n    if (!XcodeSimulatorService.isValidUrl(trimmedUrl)) {\n      throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.badUrl);\n    }\n    // Check if no simulator is presented\n    if (!simulator) {\n      // Check if Xcode is not installed\n      if (!(await XcodeService.isXcodeInstalled())) {\n        // Throw error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.xcodeInstallationMissing);\n      }\n      // Retrieve all simulators\n      const simulators = await XcodeSimulatorService.xcodeSimulators();\n      // Check if at least one simulator is booted\n      if (!simulators.some((xcodeSimulator) => xcodeSimulator.state === XcodeSimulatorState.booted)) {\n        // Otherwise throw an error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.bootedSimulatorMissing);\n      }\n    }\n    // Open URL in simulator\n    return execAsync([\"xcrun\", \"simctl\", \"openurl\", simulator?.udid ?? \"booted\", trimmedUrl].join(\" \")).then(() => {\n      // Silently launch Simulator application\n      XcodeSimulatorService.launchSimulatorApplication();\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["open_url_in_simulator_command_exports", "__export", "open_url_in_simulator_command_default", "__toCommonJS", "import_child_process", "import_util", "execAsync", "groupBy", "list", "keyProvider", "map", "value", "key", "values", "import_api", "XcodeService", "application", "execAsync", "XcodeSimulatorOpenUrlError", "reason", "XcodeSimulatorService", "execAsync", "simulators", "groupBy", "simulator", "group", "lhs", "rhs", "output", "devicesResponseJSON", "deviceGroup", "runtimeComponents", "runtime", "xcodeSimulator", "action", "bundleIdentifier", "serviceType", "url", "trimmedUrl", "XcodeSimulatorOpenUrlError", "XcodeService", "import_api", "open_url_in_simulator_command_default", "props", "toast", "XcodeSimulatorService", "error", "XcodeSimulatorOpenUrlError"]
}
